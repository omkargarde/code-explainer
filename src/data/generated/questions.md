[{"id":1,"topic":"JavaScript ES6+","difficulty":"Easy","question":"Explain the difference between `let`, `const`, and `var` regarding scope and hoisting in JavaScript.","expected_answer_outline":"Scope: `var` is function-scoped; `let` and `const` are block-scoped. Hoisting: `var` is hoisted and initialized to `undefined`; `let` and `const` are hoisted but remain uninitialized (Temporal Dead Zone) until declaration. Reassignment: `const` prevents reassignment, while `let` and `var` allow it."},{"id":2,"topic":"JavaScript Core: Closures","difficulty":"Medium","question":"What is a closure in JavaScript, and provide a common use case where closures are beneficial.","expected_answer_outline":"Definition: A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). It allows an inner function to access the scope of its outer function even after the outer function has finished executing. Use Case: Creating private variables/methods or implementing functional patterns like memoization or currying."},{"id":3,"topic":"JavaScript Asynchronicity: Promises","difficulty":"Medium","question":"Describe the states of a Promise. How does Promise chaining work, and how do you handle errors within a chain?","expected_answer_outline":"States: Pending (initial state), Fulfilled (operation completed successfully), Rejected (operation failed). Chaining: The result of one `.then()` block is passed as the input to the next. Error Handling: Handled using `.catch()` at the end of the chain, or by providing a second callback function to `.then()`."},{"id":4,"topic":"JavaScript Asynchronicity: Async/Await","difficulty":"Hard","question":"Explain how `async`/`await` functions are syntactic sugar over Promises. Demonstrate how to handle errors and parallelize multiple asynchronous calls efficiently using modern ES features.","expected_answer_outline":"`async/await` allows writing asynchronous code synchronously, internally converting functions into Promises. Error Handling: Must use standard `try...catch` blocks around the `await` calls. Parallelization: Use `Promise.all()` (or `Promise.allSettled()` for robust non-failing execution) to initiate multiple awaits concurrently rather than sequentially."},{"id":5,"topic":"JavaScript DOM Manipulation","difficulty":"Medium","question":"What is event delegation? Why is it considered a performance optimization when dealing with large lists or dynamic content?","expected_answer_outline":"Event Delegation: Attaching a single event listener to a parent element instead of multiple listeners to individual child elements. Optimization: Reduces memory usage (fewer listeners), simplifies setup/teardown, and automatically handles events for elements added to the DOM dynamically, improving performance, especially in highly interactive interfaces."},{"id":6,"topic":"React Hooks: State Management","difficulty":"Easy","question":"When updating state using `useState`, why is it often recommended to use the functional update form (passing a function to the setter) instead of relying on the current state variable directly?","expected_answer_outline":"The functional update form (`setCount(prevCount => prevCount + 1)`) guarantees that the update uses the most recent, correct state value. This is crucial when updates might be batched by React or when the state depends on its previous value, avoiding race conditions or stale closures."},{"id":7,"topic":"React Hooks: useEffect","difficulty":"Medium","question":"Explain the role of the dependency array in `useEffect`. What happens if you omit the array, and what are the implications of passing an empty array (`[]`)?","expected_answer_outline":"Dependency Array Role: Specifies which values the effect relies on. React re-runs the effect only if any value in the array changes between renders. Omitted Array: The effect runs after *every* render. Empty Array (`[]`): The effect runs only once after the initial render (mimicking `componentDidMount` and `componentWillUnmount` for cleanup)."},{"id":8,"topic":"React Hooks: Custom Hooks","difficulty":"Medium","question":"What is the primary purpose of a Custom Hook? How do they differ fundamentally from traditional helper functions in terms of React capabilities?","expected_answer_outline":"Purpose: To reuse stateful logic across different components (e.g., fetching data, handling forms, managing viewport size). Difference: Custom Hooks are functions that must call other standard React Hooks (`useState`, `useEffect`, etc.). Helper functions cannot use Hooks, meaning Custom Hooks allow sharing state, context, and lifecycle management features, whereas helpers only share pure calculations."},{"id":9,"topic":"React State Management: Context API","difficulty":"Medium","question":"Describe the Context API. When is Context a good solution for state management, and when might a library like Redux or Zustand be a better fit?","expected_answer_outline":"Context API: Provides a way to pass data through the component tree without manually passing props down at every level (prop drilling). Good Fit: For managing application-wide themes, user authentication status, or locale settings (low-frequency, global updates). Better Fit for External Libraries: When state logic is complex, requires middleware (logging, analytics), needs centralized debugging/tracing (time-travel debugging), or involves high-frequency, interrelated updates."},{"id":10,"topic":"React Performance Optimization","difficulty":"Hard","question":"Differentiate between `React.memo`, `useCallback`, and `useMemo`. Provide a scenario where all three might be used together to prevent unnecessary re-renders.","expected_answer_outline":"`React.memo`: A HOC for components to prevent re-rendering if props haven't shallowly changed. `useCallback`: Memorizes a function instance, ensuring the reference equality remains consistent across renders. `useMemo`: Memorizes the return value of a calculation. Scenario: A parent component wraps a computationally intensive child component using `React.memo`. If the parent passes a prop that is a function, that function must be wrapped in `useCallback`. If the parent passes a complex calculated value, that value must be wrapped in `useMemo`."},{"id":11,"topic":"React Lifecycle (Hooks vs. Class)","difficulty":"Medium","question":"How do you replicate the behavior of the Class component lifecycle methods `componentDidMount` and `componentWillUnmount` using only functional components and Hooks?","expected_answer_outline":"`componentDidMount`: Achieved using `useEffect` with an empty dependency array (`[]`). `componentWillUnmount`: Achieved by returning a cleanup function from within the `useEffect` hook. This returned function runs just before the component is destroyed."},{"id":12,"topic":"React Advanced Concepts","difficulty":"Hard","question":"Explain the concept of React Reconciliation and the role of the 'key' prop when rendering lists. What issues arise if keys are unstable (e.g., using array index as a key)?","expected_answer_outline":"Reconciliation: React's process of efficiently updating the DOM by comparing the new Virtual DOM tree with the previous one (diffing algorithm). Keys Role: Keys help React identify which items have changed, been added, or been removed. They provide a stable identity for elements in a list. Unstable Keys (Index): If items in the list are reordered, inserted, or deleted, using the index as a key confuses the diffing algorithm, causing React to potentially reuse DOM elements for the wrong data or run performance-intensive updates instead of simply moving elements."}]