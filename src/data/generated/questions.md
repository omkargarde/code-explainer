[{"id":1,"topic":"JavaScript Fundamentals (ES6)","difficulty":"Easy","question":"Differentiate between `var`, `let`, and `const` in terms of scope, hoisting, and reassignability. Provide an example of the Temporal Dead Zone (TDZ).","expected_answer_outline":"Scope: `var` is function-scoped; `let`/`const` are block-scoped. Hoisting: `var` is fully hoisted (initialized to `undefined`); `let`/`const` are hoisted but uninitialized (entering the TDZ). Reassignability: `let` can be reassigned; `const` cannot. TDZ is the period between entering the scope and declaration."},{"id":2,"topic":"Asynchronous JavaScript","difficulty":"Medium","question":"Explain the difference between Promise chaining (`.then()`, `.catch()`) and using `async/await`. How do you handle multiple, independent async calls concurrently using Promises?","expected_answer_outline":"Promise chaining uses callback functions; `async/await` provides syntactic sugar to make asynchronous code look synchronous. Error handling in `async/await` is done via `try/catch`. Concurrent handling is achieved using `Promise.all()` for waiting on all results, or `Promise.race()` for the fastest result."},{"id":3,"topic":"JavaScript Advanced","difficulty":"Medium","question":"What is a JavaScript closure? Describe a practical scenario where closures are essential, such as creating private variables or implementing functional currying.","expected_answer_outline":"A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). They allow access to outer function variables even after the outer function has finished executing. Useful for data privacy/encapsulation and factory functions."},{"id":4,"topic":"ES6/OOP","difficulty":"Medium","question":"Explain the significance of the `this` keyword in JavaScript. How does `this` behave differently inside a standard function versus an arrow function?","expected_answer_outline":"The value of `this` depends on how a function is called (execution context). In standard functions, `this` is dynamically scoped (determined at runtime). In arrow functions, `this` is lexically scoped (inherited from the parent scope/defined at creation) and cannot be rebound."},{"id":5,"topic":"DOM Manipulation & Performance","difficulty":"Hard","question":"You need to add 500 new elements to the DOM. Describe the most performant way to achieve this, minimizing browser reflows and repaints. Which browser API/technique would you use?","expected_answer_outline":"Use a `DocumentFragment`. This allows manipulation of the subtree in memory without directly affecting the live DOM structure. The entire fragment is then appended to the DOM in a single operation, triggering only one reflow/repaint."},{"id":6,"topic":"React Fundamentals & Hooks","difficulty":"Easy","question":"What is the primary difference between Props and State in React? Can a component modify its own props?","expected_answer_outline":"Props (Properties) are immutable and passed from parent to child. State is mutable, managed within the component, and triggers re-renders when updated. A component cannot directly modify its own props; props are read-only."},{"id":7,"topic":"React Hooks (`useEffect`)","difficulty":"Medium","question":"Explain the purpose of the dependency array in the `useEffect` hook. What are the practical implications of passing an empty array (`[]`) versus omitting the array entirely?","expected_answer_outline":"The dependency array controls when the effect runs. Empty array: The effect runs only once after the initial render (similar to `componentDidMount`). Omitted array: The effect runs after every single render. If dependencies are included, the effect runs only when those values change."},{"id":8,"topic":"React Advanced (`useMemo` & `useCallback`)","difficulty":"Hard","question":"What problem do `useCallback` and `useMemo` solve in React performance optimization? Describe a scenario where using them might actually degrade performance (The premature optimization trap).","expected_answer_outline":"They solve unnecessary re-renders of child components by memoizing functions (`useCallback`) or computed values (`useMemo`). They prevent expensive calculations or unnecessary prop changes (for reference types like functions/objects). Degradation occurs if the calculation or component being memoized is trivial, as the overhead of hook comparison/memoization outweighs the cost of re-rendering/recalculation."},{"id":9,"topic":"React State Management","difficulty":"Medium","question":"Compare `useState` with `useReducer`. When should a developer choose `useReducer` over `useState` for state management in a functional component?","expected_answer_outline":"Choose `useReducer` when state logic is complex, involves multiple related sub-values, or when the next state depends on the previous state in a predictable way. It provides better structure for debugging complex flows and centralizes dispatch logic, often making testing easier than many sequential `useState` calls."},{"id":10,"topic":"React Context API","difficulty":"Hard","question":"Describe a common performance pitfall when using the Context API for large-scale or frequently updating data (e.g., global mouse position). How can this pitfall be mitigated using component structure or hook usage?","expected_answer_outline":"Pitfall: When any value in the Context Provider changes, all consuming components, regardless of which part of the data they use, re-render. Mitigation: Split the context into smaller, specialized contexts (e.g., `UserContext` and `ThemeContext`). Alternatively, use techniques like passing dispatch/setter functions via Context and keeping the state locally, or using `useMemo` strategically on the Provider's value."},{"id":11,"topic":"React Lifecycle & Hooks Mapping","difficulty":"Medium","question":"If you were migrating a legacy Class Component, which Hooks (and configurations) would replace the functionality of `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`?","expected_answer_outline":"`componentDidMount`: `useEffect` with an empty dependency array (`[]`). `componentDidUpdate`: `useEffect` with dependencies specified in the array (e.g., `[propA, stateB]`). `componentWillUnmount`: The cleanup function returned within `useEffect`."},{"id":12,"topic":"React Architecture","difficulty":"Medium","question":"What is the primary goal of creating a Custom Hook? Provide an example of common functionality that should be encapsulated in a custom hook.","expected_answer_outline":"Primary Goal: To reuse stateful logic across multiple components without repeating code (separation of concerns). Example: Handling complex form input validation, managing browser localStorage synchronization, or handling API fetching status (loading, error, data) across different components (`useFetch`)."}]