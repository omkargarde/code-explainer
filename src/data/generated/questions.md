[{"id":1,"topic":"JavaScript: ES6 Features","difficulty":"Easy","question":"Explain the concepts of block scoping introduced by `let` and `const`. What is Temporal Dead Zone (TDZ), and how does it relate to variable hoisting?","expected_answer_outline":"Difference between function scope (`var`) and block scope (`let`/`const`). Hoisting of `let`/`const` variables (hoisted but uninitialized). TDZ is the period from the start of the block until the variable is declared, where accessing the variable throws a ReferenceError."},{"id":2,"topic":"JavaScript: Closures","difficulty":"Medium","question":"Describe what a closure is in JavaScript. Provide a practical example of how closures can be used to achieve data privacy (encapsulation).","expected_answer_outline":"A closure is a function bundled with its lexical environment. It allows a function to access variables from its outer scope even after the outer function has finished executing. Practical example: Creating a factory function that returns methods to interact with a private counter variable (e.g., a counter incrementer)."},{"id":3,"topic":"JavaScript: Promises and Async/Await","difficulty":"Medium","question":"Differentiate between a Promise chain using `.then()` and asynchronous code using `async/await`. When handling errors in `async/await`, why must we use `try...catch` blocks?","expected_answer_outline":"Promises use callbacks for sequence control and require explicit chaining. `async/await` is syntactic sugar that allows asynchronous code to be written synchronously, improving readability. Errors (rejections) in `async/await` are not automatically caught by surrounding Promise catchers; they propagate like synchronous errors and must be handled via standard JavaScript `try...catch` blocks."},{"id":4,"topic":"JavaScript: Concurrency Model","difficulty":"Hard","question":"Explain the JavaScript Event Loop. Specifically, differentiate the execution timing and priority between Microtasks (like Promises) and Macrotasks (like `setTimeout`).","expected_answer_outline":"The Event Loop manages concurrency by moving tasks from the queue to the Call Stack. Macrotasks (timers, I/O) are executed sequentially, one per loop iteration. Microtasks (Promise resolutions, `queueMicrotask`) have higher priority; they are executed entirely and drained immediately after the current script execution stack clears, and before the next Macrotask is processed."},{"id":5,"topic":"React: Hooks (useState/useEffect)","difficulty":"Easy","question":"When using `useState` in functional components, why is it crucial to remember that state updates are asynchronous and batched? How can you ensure an update relies on the previous state value?","expected_answer_outline":"Updates are asynchronous and batched by React for performance optimization. To ensure reliable updates based on previous state (especially in scenarios like counters), the functional update form must be used: `setCount(prevCount => prevCount + 1)`."},{"id":6,"topic":"React: Hooks (useReducer)","difficulty":"Medium","question":"Compare `useState` and `useReducer`. In which scenarios does `useReducer` offer a clear advantage in managing component state?","expected_answer_outline":"`useState` is for simple state management. `useReducer` is for complex state logic, where the next state depends on the previous state, or when there are multiple related state transitions (state machine patterns). Advantage: Centralized update logic (the reducer function) and easier testing/debugging of complex interactions."},{"id":7,"topic":"React: Performance Optimization","difficulty":"Medium","question":"How do `React.memo`, `useCallback`, and `useMemo` work together to prevent unnecessary re-renders in a complex component tree? Provide a scenario where combining all three is essential.","expected_answer_outline":"`React.memo` (HOC) shallowly compares props of a functional component to skip rendering. `useMemo` caches the result of expensive calculations. `useCallback` caches the function instance itself. They are essential when passing functions/objects as props to a memoized child component (`React.memo`), ensuring the reference equality holds and the child doesn't re-render unnecessarily."},{"id":8,"topic":"React: Context API","difficulty":"Medium","question":"Explain the 'prop drilling' problem. How does the Context API solve this, and what is the primary performance drawback of using a single global context for unrelated data?","expected_answer_outline":"Prop drilling is passing props down through many layers of components that don't need them. Context API solves this by providing a way to share data globally, accessible directly by consumers. Drawback: If the value provided by the Context Provider changes, *all* components consuming that context (even if they only use a small, unchanged part of the context object) will re-render, potentially causing performance bottlenecks."},{"id":9,"topic":"React: Component Lifecycle (Conceptual)","difficulty":"Hard","question":"Before hooks, class components relied on lifecycle methods. Conceptualize how `useEffect` replaces the functionality previously handled by `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.","expected_answer_outline":"`componentDidMount` (initial side effects) is replaced by `useEffect` with an empty dependency array (`[]`). `componentDidUpdate` (reactions to changes) is replaced by `useEffect` with specific dependencies (`[dep1, dep2]`). `componentWillUnmount` (cleanup) is replaced by the function returned by the `useEffect` hook."},{"id":10,"topic":"React: State Management (Advanced)","difficulty":"Hard","question":"In the context of modern React development without external libraries (like Redux), how would you structure state management for a large application that requires high performance and distributed updates? Discuss using component composition, Context, and `useReducer` for scaling.","expected_answer_outline":"Suggest lifting state up where necessary, but using multiple, modular Contexts (e.g., AuthContext, ThemeContext, CartContext) combined with `useReducer` inside the providers. This avoids the single-context performance penalty. Using techniques like component composition (`children` prop) ensures presentation components are decoupled from logic and state providers, maximizing reusability and minimizing renders."}]