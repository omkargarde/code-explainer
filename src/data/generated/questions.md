[{"id":101,"topic":"JavaScript: Scope and Hoisting (ES6)","difficulty":"Easy","question":"Explain the difference between `var`, `let`, and `const` in JavaScript, specifically focusing on their scoping rules and hoisting behavior.","expected_answer_outline":"Scope (var: function-scoped; let/const: block-scoped). Hoisting (var: initialized as undefined; let/const: hoisted but remain in the Temporal Dead Zone until declaration). Reassignment/Redeclaration rules."},{"id":102,"topic":"JavaScript: Closures","difficulty":"Medium","question":"What is a closure? Provide a brief code example demonstrating how closures are used to create private variables or encapsulate data in JavaScript.","expected_answer_outline":"Definition: A function bundled with its surrounding state (lexical environment). Example should show an outer function returning an inner function, where the inner function still has access to the outer function's variables even after the outer function has finished executing."},{"id":103,"topic":"JavaScript: Asynchronous Operations","difficulty":"Medium","question":"Compare and contrast Promises with `async`/`await`. How does `async`/`await` improve readability and error handling in complex asynchronous flows?","expected_answer_outline":"Async/Await is syntactic sugar over Promises. Improves readability by making asynchronous code look synchronous. Error handling uses standard `try...catch` blocks instead of `.catch()` chains, simplifying flow control."},{"id":104,"topic":"JavaScript: DOM Manipulation","difficulty":"Hard","question":"Write the JavaScript steps necessary to dynamically create a new button element, assign it an event listener that logs 'Clicked!' when pressed, and append it as the first child of a container element with the ID 'main-content'.","expected_answer_outline":"Use `document.createElement('button')`. Set `textContent` or `innerHTML`. Use `addEventListener('click', ...)` for the handler. Use `document.getElementById('main-content')` and then use `prepend()` or `insertBefore()` to position it correctly."},{"id":201,"topic":"React: Basic Hooks","difficulty":"Easy","question":"What are React Hooks? Explain the difference between `useState` and using local state in class components.","expected_answer_outline":"Hooks allow functional components to use state and lifecycle features. `useState` returns a state variable and an update function (array destructuring). Unlike class component state, `useState` setters replace the state rather than merging it (unless an object spread is used manually)."},{"id":202,"topic":"React: useEffect Hook","difficulty":"Medium","question":"Explain the dependency array of the `useEffect` hook. Describe what happens in three different scenarios: 1) dependency array is omitted, 2) it is an empty array (`[]`), and 3) it contains dependencies.","expected_answer_outline":"Controls when the side effect re-runs. 1) Omitted: Runs on every render. 2) Empty array: Runs only once (simulates `componentDidMount`). 3) Contains dependencies: Runs once initially, and subsequently whenever any listed value changes (simulates `componentDidUpdate`)."},{"id":203,"topic":"React: Performance Optimization","difficulty":"Medium","question":"In the context of performance optimization in React, explain the roles of `React.memo`, `useCallback`, and `useMemo`. When would you use these three tools together?","expected_answer_outline":"`React.memo`: Higher-order component for preventing re-renders of functional components if props haven't changed. `useCallback`: Memoizes a function instance. `useMemo`: Memoizes a computed value. They are used together when passing memoized functions (`useCallback`) and memoized values (`useMemo`) as props to a child component wrapped in `React.memo`."},{"id":204,"topic":"React: State Management (Context API)","difficulty":"Medium","question":"Describe the React Context API. What are its primary advantages, and what critical limitation must developers be aware of when using Context for frequently updated state?","expected_answer_outline":"Context provides a way to pass data through the component tree without prop drilling. Advantage: simplifies global state (like theme/user auth). Limitation: When Context updates, *all* consuming components re-render, even if they only use a subset of the context data, leading to performance issues if the state updates frequently."},{"id":205,"topic":"React: Custom Hooks","difficulty":"Easy","question":"What is the primary motivation for creating a custom hook? Provide an example of a common scenario where a custom hook (e.g., `useLocalStorage`) would be beneficial.","expected_answer_outline":"Motivation: To reuse stateful logic across multiple components easily. Example: Managing browser storage, handling form state, or integrating external APIs (`useFetch`). The hook encapsulates the `useState` and `useEffect` logic."},{"id":206,"topic":"React: Lifecycle (Modern vs. Class)","difficulty":"Hard","question":"How do you handle lifecycle stages equivalent to `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` using the `useEffect` hook?","expected_answer_outline":"`componentDidMount`: `useEffect` with an empty dependency array (`[]`). `componentDidUpdate`: `useEffect` with specific dependencies in the array. `componentWillUnmount`: Returning a cleanup function from within the `useEffect` callback."}]