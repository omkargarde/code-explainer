[{"id":1,"topic":"JavaScript ES6+","difficulty":"Easy","question":"Explain the differences between `var`, `let`, and `const` in JavaScript, focusing on scoping and hoisting.","expected_answer_outline":"Scope: `var` is function-scoped; `let`/`const` are block-scoped. Hoisting: `var` is fully hoisted (initialized with undefined); `let`/`const` are hoisted but remain in the Temporal Dead Zone until initialized. Reassignment: `let` can be reassigned; `const` cannot (must be initialized upon declaration)."},{"id":2,"topic":"JavaScript Closures","difficulty":"Medium","question":"What is a closure in JavaScript, and provide a simple code example demonstrating its practical use, such as creating a private counter.","expected_answer_outline":"A function bundled with its lexical environment (the scope chain where it was defined). It allows an inner function to access variables from its outer (enclosing) function even after the outer function has finished executing. Practical use includes module patterns, currying, and maintaining private state."},{"id":3,"topic":"JavaScript Promises","difficulty":"Medium","question":"Explain the concept of Promises and describe the three possible states of a Promise. How does Promise chaining work using `.then()` and `.catch()`?","expected_answer_outline":"Promises manage asynchronous operations, representing an eventual value or error. States: Pending, Fulfilled (Resolved), Rejected. Chaining: `.then()` handles success and returns a new promise, allowing sequential async operations. `.catch()` handles errors anywhere in the chain."},{"id":4,"topic":"JavaScript Async/Await","difficulty":"Medium","question":"How does `async/await` simplify asynchronous code handling compared to traditional Promise chaining (`.then()`)? Write a short example of an async function fetching data.","expected_answer_outline":"`async/await` is syntactic sugar built on Promises. It makes asynchronous code look synchronous, improving readability and error handling (using standard `try...catch`). `await` pauses execution until the promise settles. Must be used inside an `async` function."},{"id":5,"topic":"JavaScript ES10+","difficulty":"Medium","question":"Discuss the primary use cases for the Nullish Coalescing Operator (`??`) and Optional Chaining (`?.`). How do they improve code safety?","expected_answer_outline":"Optional Chaining (`?.`) safely accesses deeply nested object properties without checking for intermediate null/undefined values, preventing runtime crashes. Nullish Coalescing (`??`) returns the right-hand operand only if the left-hand operand is strictly `null` or `undefined` (unlike `||` which checks all falsy values like 0 or '')."},{"id":6,"topic":"JavaScript DOM Manipulation","difficulty":"Hard","question":"You need to dynamically add 100 new elements to the DOM. Describe the most performance-efficient approach, explaining why manipulating the DOM frequently is detrimental.","expected_answer_outline":"Frequent DOM manipulation causes expensive reflows/repaints. The efficient approach is to use a `DocumentFragment`. Append all 100 elements to the fragment first (which operates off-screen), and then append the single fragment to the real DOM once, minimizing layout calculations."},{"id":7,"topic":"React Virtual DOM","difficulty":"Medium","question":"Explain the concept of the React Virtual DOM (VDOM) and the reconciliation process. Why is the VDOM beneficial for performance?","expected_answer_outline":"VDOM is a lightweight, in-memory representation of the real DOM. Reconciliation is the 'diffing' process where React compares the new VDOM tree with the previous VDOM tree to find the minimum set of changes required. This allows React to batch updates and apply only necessary changes to the slow, physical DOM."},{"id":8,"topic":"React Hooks","difficulty":"Easy","question":"What are the primary responsibilities of the `useState` and `useEffect` hooks? When using `useEffect`, what happens if you omit the dependency array?","expected_answer_outline":"`useState` provides state management for functional components. `useEffect` handles side effects (data fetching, subscriptions, manual DOM manipulation). If the dependency array is omitted, the effect runs after every render, often leading to performance issues or infinite loops."},{"id":9,"topic":"React Hooks Advanced","difficulty":"Medium","question":"Explain the purpose of `useCallback` and `useMemo`. Provide a scenario where using one of them would prevent an unnecessary re-render in a child component.","expected_answer_outline":"`useMemo` memoizes (caches) a computed value, preventing recalculation on every render. `useCallback` memoizes a function definition, preventing the function from being recreated on every render. Use Case: Passing a memoized function (`useCallback`) as a prop to a child component wrapped in `React.memo`â€”this prevents the child from re-rendering unnecessarily because the prop reference remains stable."},{"id":10,"topic":"React Lifecycle","difficulty":"Medium","question":"If you were using Class Components, describe the equivalent lifecycle phases for component mounting, updating, and unmounting. How do these map to the `useEffect` hook in Functional Components?","expected_answer_outline":"Mounting: `componentDidMount`. Updating: `componentDidUpdate`. Unmounting: `componentWillUnmount`. In `useEffect`: Mounting and Updating are handled by the effect function based on the dependency array. Unmounting is handled by the cleanup function returned by `useEffect`."},{"id":11,"topic":"React State Management / Context API","difficulty":"Medium","question":"What is 'prop drilling,' and how does the Context API help mitigate it? What is the main limitation of the Context API for large-scale, high-frequency state updates?","expected_answer_outline":"Prop drilling is passing props down through many layers of components that don't need the data themselves. Context API allows state to be accessed directly by consumers deep in the tree. Limitation: When the Context value changes, *all* consuming components re-render, which can lead to performance bottlenecks for complex, frequently updated global state (where tools like Redux or Zustand are often preferred)."},{"id":12,"topic":"React Performance Optimization","difficulty":"Hard","question":"A complex child component is re-rendering even though its visible props and internal state have not changed. List the steps you would take to debug and resolve this issue.","expected_answer_outline":"Debugging: Use React Developer Tools Profiler to identify the initiator of the re-render (usually a parent). Potential Causes/Resolutions: 1. Parent is re-rendering and the child is receiving new function/object references (inline definitions). Resolution: Wrap the child component in `React.memo`. 2. Ensure objects/arrays passed as props are stable (using `useMemo` for complex props). 3. Verify dependency arrays in the child's hooks are correct."}]