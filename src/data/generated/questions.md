[{"id":1,"topic":"JavaScript ES6 Fundamentals","difficulty":"Medium","question":"Explain the difference between `let`, `const`, and `var` in terms of scoping and hoisting. Provide a scenario where using `const` might still allow modification of the underlying data.","expected_answer_outline":"Scope: `var` is function-scoped; `let`/`const` are block-scoped. Hoisting: `var` is hoisted and initialized as `undefined`; `let`/`const` are hoisted but remain in the Temporal Dead Zone (TDZ). Modification: `const` prevents reassignment, but if it holds an object or array, the properties/elements within that object/array can still be mutated (e.g., `const obj = {a: 1}; obj.a = 2;`)."},{"id":2,"topic":"JavaScript Advanced Concepts","difficulty":"Medium","question":"Define closures in JavaScript. Provide a practical example of how closures are used, focusing on data privacy or creating function factories.","expected_answer_outline":"Definition: A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). Utility: They enable functions to access variables from an outer scope even after the outer function has finished executing. Example must demonstrate creating private variables or maintaining state (e.g., a counter function factory)."},{"id":3,"topic":"Asynchronous JavaScript (Promises)","difficulty":"Medium","question":"Differentiate between `Promise.all()` and `Promise.race()`. What happens to `Promise.all()` if one of the promises in the iterable rejects?","expected_answer_outline":"`Promise.all()` waits for all promises in the array to resolve, or for the first one to reject. If all resolve, it returns an array of results. If one rejects, `Promise.all()` immediately rejects with that promise's error. `Promise.race()` returns a promise that resolves or rejects as soon as one of the input promises resolves or rejects, 'winning' the race."},{"id":4,"topic":"Asynchronous JavaScript (Async/Await)","difficulty":"Hard","question":"How do you handle synchronous and asynchronous errors when using `async`/`await`? Provide code demonstrating robust error handling, including potential pitfalls like unhandled promise rejections inside loops.","expected_answer_outline":"Errors in `async`/`await` are typically handled using standard `try...catch` blocks. The `await` keyword effectively turns a rejected promise into a caught error. The response should demonstrate wrapping the await call in a try/catch. Mentioning that `.catch()` is still necessary if the `async` function itself is called without an outer `await` or `try...catch` is a bonus point."},{"id":5,"topic":"DOM Manipulation and Events","difficulty":"Medium","question":"Explain event delegation. Why is it a preferable pattern for managing events on large dynamic lists compared to attaching listeners to every single element?","expected_answer_outline":"Event Delegation involves attaching a single event listener to a parent element instead of multiple listeners to child elements. The event listener then uses properties like `event.target` to identify which descendant element originated the event. Preference: Reduces memory footprint (fewer listeners), simplifies code for dynamically added/removed elements (no need to constantly manage listeners), and improves performance."},{"id":6,"topic":"React Hooks (useEffect)","difficulty":"Medium","question":"Explain the role and functionality of the dependency array in the `useEffect` hook. Provide examples of how to replicate `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` using `useEffect`.","expected_answer_outline":"Role: The dependency array determines when the effect should re-run. Empty array `[]`: Runs once after initial render (like `componentDidMount`). Omitted array: Runs after every render (mount and update). Array with values `[a, b]`: Runs only when `a` or `b` changes (like `componentDidUpdate`). Cleanup Function (return statement): Runs before the component unmounts or before the effect runs again (like `componentWillUnmount`)."},{"id":7,"topic":"React Hooks (Optimization)","difficulty":"Hard","question":"When and why would a developer use `useMemo` versus `useCallback`? Illustrate a scenario where using `useCallback` is critical for performance.","expected_answer_outline":"`useMemo` memoizes (caches) the result of a function call (a value) to prevent expensive calculations on every render. `useCallback` memoizes the function definition itself, preventing unnecessary re-creation of functions across renders. Critical Scenario: `useCallback` is essential when passing functions down to optimized child components that rely on `React.memo` or `shouldComponentUpdate`. Without `useCallback`, the child component will unnecessarily re-render because a new function reference is created on every parent render."},{"id":8,"topic":"React State Management","difficulty":"Medium","question":"Describe the main purpose of the Context API. What limitations does it have when used for global state management in a highly interactive application compared to libraries like Redux or Zustand?","expected_answer_outline":"Purpose: Context API allows data (state, functions, theme) to be passed deep down the component tree without prop drilling. Limitations: Context API often causes large, centralized re-renders. If a component consumes a value from a context and that context value changes, *all* consuming components, even those only using unrelated data fields from that context, will re-render. Specialized libraries allow for granular subscription and optimized updates."},{"id":9,"topic":"React Fundamentals/Reconciliation","difficulty":"Medium","question":"Explain the significance of the `key` prop when rendering lists in React. What happens if unique keys are not provided, or if the index is used as the key when the list order might change?","expected_answer_outline":"Significance: Keys help React's Reconciliation algorithm identify which items in a list have been added, removed, or reordered. They must be stable, unique identifiers among siblings. Problem with Index Keys: If the list is dynamically sorted, filtered, or items are inserted/deleted mid-list, using the index as the key causes React to misuse the key for item identity. This leads to inefficient re-rendering, potential state mix-ups (e.g., input values transferring to the wrong element), and loss of component state."},{"id":10,"topic":"React Performance Optimization","difficulty":"Hard","question":"A complex React component is re-rendering frequently even when its immediate props haven't changed. Describe three distinct methods or tools you would use to debug and optimize this unnecessary re-rendering.","expected_answer_outline":"1. **Profiling/Debugging Tools:** Use React DevTools Profiler to visualize which components are re-rendering and why (identifying the root cause, usually a parent state change). 2. **Memoization:** Apply `React.memo` (or `PureComponent` for classes) to the component to prevent re-render unless props change. Ensure that objects/arrays passed as props are memoized upstream using `useMemo` or functions using `useCallback`. 3. **Context Segmentation/State Colocation:** If using Context, split large contexts into smaller ones. Move state closer to where it is used (colocation) to minimize the number of components affected by state updates."}]