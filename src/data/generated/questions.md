[{"id":1,"topic":"JavaScript ES6+","difficulty":"Easy","question":"Explain the differences between `var`, `let`, and `const` in JavaScript, specifically focusing on scope and hoisting.","expected_answer_outline":"Scope: `var` is function-scoped; `let`/`const` are block-scoped. Hoisting: All are hoisted, but `var` initializes with `undefined`, while `let`/`const` remain uninitialized (Temporal Dead Zone) until declaration. `const` requires initialization upon declaration."},{"id":2,"topic":"JavaScript Closures","difficulty":"Medium","question":"What is a closure? Provide a brief code example illustrating its use case, such as creating a private counter.","expected_answer_outline":"A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). They allow inner functions to access the scope of outer functions even after the outer function has finished executing. Example must show an immediately invoked function expression (IIFE) or a factory function returning another function to maintain state privacy."},{"id":3,"topic":"JavaScript Promises","difficulty":"Medium","question":"Describe the three states of a JavaScript Promise and explain the role of `.then()`, `.catch()`, and `.finally()` methods.","expected_answer_outline":"States: Pending (initial), Fulfilled (resolved, successful), and Rejected (failed). `.then()` handles successful fulfillment. `.catch()` handles rejection errors. `.finally()` executes regardless of success or failure, typically for cleanup tasks."},{"id":4,"topic":"JavaScript Async/Await","difficulty":"Medium","question":"How does `async/await` syntax simplify asynchronous code compared to using traditional Promise chaining (`.then()`)? What mechanism ensures that `await` doesn't block the main thread?","expected_answer_outline":"`Async/await` provides synchronous-looking code structure, improving readability and error handling (using standard `try/catch`). The underlying mechanism is still Promises and the Event Loop; `await` pauses execution of the *async function* itself, releasing control back to the event loop temporarily."},{"id":5,"topic":"JavaScript DOM Manipulation","difficulty":"Easy","question":"When dynamically adding a large list of elements (say, 100 list items) to the DOM, what technique should be used to minimize repaint/reflow operations and ensure good performance?","expected_answer_outline":"Use Document Fragment or build the entire list structure as a single string/template literal and use `innerHTML` once, or perform all DOM modifications while the element is detached from the main DOM tree, then attach it back (Batching DOM writes)."},{"id":6,"topic":"React Hooks","difficulty":"Medium","question":"Explain the purpose of the dependency array in the `useEffect` hook. What happens if you omit the array, and what happens if you pass an empty array?","expected_answer_outline":"The dependency array specifies when the effect should re-run. Omitted array: Runs after every render. Empty array (`[]`): Runs only once after the initial render (mimicking `componentDidMount`). Not providing required dependencies can lead to stale closures/stale state."},{"id":7,"topic":"React State Management","difficulty":"Medium","question":"When updating state based on the previous state in React (e.g., toggling a boolean or incrementing a counter), why is it critical to use the functional update form of `setState` or `useState`?","expected_answer_outline":"React batches state updates for performance. Using the functional form (`setCount(prevCount => prevCount + 1)`) guarantees that the update uses the most current, reliable previous state value, preventing race conditions or incorrect state calculations if multiple updates occur concurrently."},{"id":8,"topic":"React Life Cycle Methods (LCP)","difficulty":"Easy","question":"If you are working with a legacy Class Component, which life cycle method would you use to fetch data immediately after the component mounts for the first time?","expected_answer_outline":"`componentDidMount()`. This method executes once after the component and its children have been rendered to the DOM."},{"id":9,"topic":"React Performance Optimization","difficulty":"Hard","question":"Differentiate clearly between `useMemo` and `useCallback`. Provide a scenario where misusing `useCallback` might actually hurt performance.","expected_answer_outline":"`useMemo` memoizes a value (a result of a function calculation), preventing re-calculation on every render unless dependencies change. `useCallback` memoizes a function definition itself, ensuring the function reference remains stable. Misuse: Overusing `useCallback` on simple functions or functions passed to standard HTML elements adds overhead (creation/comparison of memoized value) that outweighs the cost of re-creation."},{"id":10,"topic":"React Context API","difficulty":"Medium","question":"The Context API is often used for global state management. What is its main limitation when dealing with frequently updated, complex state, and how can the `useReducer` hook help mitigate this limitation?","expected_answer_outline":"Limitation: When a Provider's value updates, *all* consuming components (even if they only use a small subset of the context data) re-render. `useReducer` helps by centralizing complex logic, and components can be structured to consume specific parts of the context/dispatch function separately, often paired with memoization, although unnecessary re-renders in consumers still require optimization (like splitting context or using custom hooks)."},{"id":11,"topic":"React Lists and Keys","difficulty":"Medium","question":"What is the primary significance of the `key` prop when rendering a list of elements in React? What problems arise if an array index is used as the key when the list order changes?","expected_answer_outline":"Keys help React identify which items have changed, are added, or are removed. They are essential for efficient reconciliation (Virtual DOM diffing). Using index as a key leads to issues when the list is sorted, filtered, or items are inserted/deleted mid-list, as React loses track of the identity of the specific element and may incorrectly reuse internal state (like input values)."},{"id":12,"topic":"JavaScript ES6 (Spread/Rest)","difficulty":"Medium","question":"Explain the difference in usage and function between the Spread operator (`...`) and the Rest parameter (`...`).","expected_answer_outline":"Spread operator expands iterables (like arrays or objects) into individual elements (e.g., merging arrays, passing arguments). Rest parameter collects multiple independent arguments into a single array (always used in function definitions or array destructuring)."},{"id":13,"topic":"React Hooks (Custom)","difficulty":"Medium","question":"What is the primary benefit of creating a Custom Hook in React, and what rule must all Custom Hooks follow regarding naming conventions?","expected_answer_outline":"Benefit: Reusing stateful logic across multiple components without duplicating code (e.g., handling form inputs, managing local storage). Rule: All Custom Hooks must start with the prefix `use` (e.g., `useFetchData`)."},{"id":14,"topic":"React Performance/Virtual DOM","difficulty":"Hard","question":"Explain the concept of Reconciliation in React and how the Virtual DOM uses a 'diffing algorithm' to minimize direct manipulation of the actual DOM.","expected_answer_outline":"Reconciliation is React's process of comparing the new Virtual DOM tree with the previous one. The diffing algorithm compares elements layer by layer, focusing on two main rules (different element types yield a full re-render; keys maintain identity). By batching updates and only applying the necessary minimal changes (patches) to the real DOM, performance is significantly improved."}]