[{"id":1,"topic":"JavaScript ES6+","difficulty":"Medium","question":"Explain the temporal dead zone (TDZ) in JavaScript. How does it relate to 'let' and 'const' compared to 'var'?","expected_answer_outline":"TDZ is the period between variable creation and initialization. 'let'/'const' variables are hoisted but not initialized, resulting in a ReferenceError if accessed during TDZ. 'var' is initialized to 'undefined' during hoisting, bypassing the TDZ issue."},{"id":2,"topic":"JavaScript Advanced Concepts","difficulty":"Medium","question":"Define a closure and provide a practical example where closures are necessary for maintaining state or data privacy.","expected_answer_outline":"A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). Key uses: creating private variables, function factories, and handling asynchronous callbacks where the function needs access to scope variables."},{"id":3,"topic":"JavaScript Asynchronous Programming","difficulty":"Hard","question":"Describe the difference between Promises, `async/await`, and callbacks. Furthermore, explain the role of the Microtask Queue and the Event Loop in handling promise resolution.","expected_answer_outline":"Callbacks lead to callback hell. Promises structure async operations. async/await is syntactic sugar over Promises, making code look synchronous. Promise resolutions are placed in the Microtask Queue, which is prioritized by the Event Loop to run *before* the next rendering/Macrotask (like setTimeout)."},{"id":4,"topic":"React Hooks and State Management","difficulty":"Medium","question":"When would you prefer using `useReducer` over `useState` in a functional component? Provide an example scenario.","expected_answer_outline":"`useReducer` is preferred when state logic is complex, involves multiple sub-values, or when the next state depends on the previous one (e.g., shopping cart management, complex forms). It centralizes state transitions outside the component, making testing easier."},{"id":5,"topic":"React Lifecycle and `useEffect`","difficulty":"Medium","question":"Explain how the dependency array in `useEffect` controls side effects. What is the cleanup function, and when is it executed?","expected_answer_outline":"The dependency array dictates when the effect runs (empty [] = mount/unmount; populated [dep] = mount and update if dep changes; none = run on every render). The cleanup function (return function inside useEffect) executes just before the component unmounts OR before the effect re-runs due to a dependency change."},{"id":6,"topic":"React Context API","difficulty":"Hard","question":"What is the primary performance pitfall when using the Context API for widely shared state, and what strategies can be used to mitigate unnecessary re-renders?","expected_answer_outline":"The pitfall is that *any* component consuming a Context will re-render if *any* value in the Context Provider changes. Mitigation strategies include splitting context into multiple, smaller contexts (Data Context and Dispatch Context) or using tools like Redux/Zustand when global state changes are highly frequent and localized context splitting is insufficient."},{"id":7,"topic":"React Performance Optimization","difficulty":"Medium","question":"Explain the practical difference between `React.memo`, `useCallback`, and `useMemo`. When should each of these be applied to optimize a component hierarchy?","expected_answer_outline":"`React.memo` prevents re-render if props haven't changed (for components). `useCallback` memoizes functions/callbacks so they don't change identity between renders (useful for passing to `React.memo` children). `useMemo` memoizes expensive calculated values/objects."},{"id":8,"topic":"JavaScript DOM Manipulation","difficulty":"Medium","question":"If you needed to add 100 list items to an existing unordered list in the DOM, describe the most performant method to achieve this and why.","expected_answer_outline":"The most performant method is using `DocumentFragment`. We append the 100 new elements to the DocumentFragment first, and then append the single DocumentFragment to the real DOM list element. This minimizes direct DOM manipulation, resulting in only one expensive reflow/repaint operation instead of 100."},{"id":9,"topic":"React Advanced Hooks/Custom Hooks","difficulty":"Hard","question":"Design the outline of a custom hook, `useFetch`, that handles asynchronous data fetching and returns the current state (loading, data, error) to the consuming component.","expected_answer_outline":"The hook must use `useState` for loading, data, and error states. It should utilize `useEffect` to initiate the fetch call, clean up effects (using `AbortController` or a mounting flag) to prevent state updates on unmounted components, and handle success/catch blocks to update the respective states."},{"id":10,"topic":"JavaScript Prototypes and Inheritance","difficulty":"Medium","question":"How does prototypal inheritance work in JavaScript, and how do ES6 classes relate to the prototype chain?","expected_answer_outline":"Objects inherit features from their prototype object. The prototype chain links objects until null is reached. ES6 classes are primarily syntactic sugar over the existing prototypal inheritance mechanism; the 'extends' keyword sets up the prototype chain automatically."}]