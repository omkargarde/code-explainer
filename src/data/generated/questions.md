[{"id":1,"topic":"JavaScript ES6+","difficulty":"Easy","question":"Differentiate between `var`, `let`, and `const` in JavaScript regarding hoisting, scoping, and reassignability.","expected_answer_outline":"Scope: `var` is function-scoped; `let` and `const` are block-scoped (ES6). Hoisting: `var` is fully hoisted (initialized to undefined); `let` and `const` are hoisted but inaccessible before declaration (Temporal Dead Zone). Reassignment: `var` and `let` can be reassigned; `const` cannot (though object properties can be mutated)."},{"id":2,"topic":"JavaScript Asynchronous","difficulty":"Medium","question":"Explain the concept of Promises. How does `async/await` simplify asynchronous code handling compared to traditional promise chaining?","expected_answer_outline":"Promises represent a value that might be available now, or in the future (Pending, Fulfilled, Rejected states). Async/Await provides syntactic sugar to work with Promises sequentially, making asynchronous code look synchronous. Await pauses execution until the promise resolves. Error handling moves from `.catch()` to standard `try...catch` blocks."},{"id":3,"topic":"JavaScript Closures","difficulty":"Medium","question":"What is a closure in JavaScript? Provide a real-world use case where closures are essential.","expected_answer_outline":"A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). It allows a function to retain access to variables from its outer scope even after the outer function has finished executing. Use cases include: creating private variables/data encapsulation, currying, and maintaining state in event handlers."},{"id":4,"topic":"JavaScript DOM Manipulation","difficulty":"Medium","question":"Describe the difference between Event Bubbling and Event Capturing. How do you implement 'Event Delegation' effectively?","expected_answer_outline":"Bubbling: Events propagate from the target element up to the window. Capturing: Events propagate from the window down to the target element. Event Delegation utilizes bubbling by placing a single event listener on a common parent element, rather than individual children. This improves performance and simplifies management of dynamically added elements."},{"id":5,"topic":"JavaScript ES6+","difficulty":"Hard","question":"Explain the key differences between `Object.assign()` and the Spread operator (`{...}`) when dealing with object copying and deep nesting.","expected_answer_outline":"Both create shallow copies. `Object.assign()` copies enumerable properties from source to target. The Spread operator creates a new object instance and copies properties. Crucially, neither performs a deep clone; if a property value is another object, only the reference is copied, leading to mutation risks in nested structures. Deep cloning requires dedicated methods (like structuredClone or utility libraries)."},{"id":6,"topic":"React Hooks","difficulty":"Medium","question":"Explain the purpose of the dependency array in the `useEffect` hook. What happens if you omit the array, or include a function reference inside it?","expected_answer_outline":"The dependency array controls when the side effect runs. Omitting it causes the effect to run after every render. An empty array (`[]`) causes it to run only on mount and cleanup on unmount. Including a stale function reference means the effect might run unexpectedly or less often than required; stable references (`useCallback`) should be used if functions must be dependencies."},{"id":7,"topic":"React Component Lifecycle & Hooks","difficulty":"Medium","question":"If you were converting a Class component, which had logic inside `componentDidUpdate`, what is the precise equivalent using the `useEffect` hook?","expected_answer_outline":"`componentDidUpdate` is equivalent to using `useEffect` with a dependency array containing the specific variables/props you wish to track. The comparison of old state/props to new state/props (which was manual in classes) is handled automatically by React ensuring the effect only runs when dependencies change."},{"id":8,"topic":"React State Management","difficulty":"Medium","question":"When would you choose `useReducer` over `useState` for managing component state?","expected_answer_outline":"`useReducer` is preferred when the state logic is complex, involves multiple related sub-values, or when the next state depends heavily on the previous state. It centralizes state updates via 'actions' (similar to Redux), making the logic easier to test and predict, especially useful when deep updating immutable state."},{"id":9,"topic":"React Context API","difficulty":"Medium","question":"Describe a scenario where using the React Context API would lead to performance degradation, and suggest an alternative solution.","expected_answer_outline":"Context causes performance issues when the Provider holds a frequently changing value (like theme or user input) that is consumed by many deep components. Since any change in the Provider value forces a re-render of *all* consumers, performance degrades quickly. Alternative: Split the global state into multiple smaller Contexts (e.g., separating user data from UI preferences) or utilize a dedicated global state management library (like Redux or Zustand) for high-frequency updates."},{"id":10,"topic":"React Performance Optimization","difficulty":"Hard","question":"Explain the difference between `React.memo`, `useMemo`, and `useCallback`. When should a developer use each one, and what common anti-pattern should be avoided?","expected_answer_outline":"`React.memo`: Higher-Order Component for functional components, prevents re-render if props are shallowly equal. `useMemo`: Caches the result of an expensive calculation (a value) between renders. `useCallback`: Caches the function instance itself (reference) between renders, critical for passing stable references to memoized child components or as `useEffect` dependencies. Anti-pattern: Using these indiscriminately ('premature optimization'); only use them when profiling shows measurable performance bottlenecks."},{"id":11,"topic":"React Rendering & Reconciliation","difficulty":"Hard","question":"What is the Virtual DOM, and how does React's Reconciliation process work to minimize direct DOM manipulation?","expected_answer_outline":"The Virtual DOM (VDOM) is a lightweight JavaScript representation of the actual browser DOM. Reconciliation (or 'diffing') is the algorithm React uses: when state/props update, React compares the new VDOM tree with the previous VDOM tree. It identifies the minimal set of changes (diffs) required and batches these updates before applying them efficiently to the real DOM, reducing expensive layout and paint operations."},{"id":12,"topic":"React Forms and Controlled Components","difficulty":"Easy","question":"Define a Controlled Component in React and explain why they are generally preferred over Uncontrolled Components for managing form state.","expected_answer_outline":"A Controlled Component is an input element whose value is managed entirely by React state. The state is the 'single source of truth.' They are preferred because they allow React to instantly validate, modify, or format input data, and easily control submission logic. Uncontrolled components typically rely on refs to access DOM values directly."}]