[{"id":1,"topic":"JavaScript: Scope & ES6","difficulty":"Medium","question":"Explain the difference between `var`, `let`, and `const` regarding scope (function vs block) and hoisting. Provide a practical scenario where using `let` over `var` prevents a common pitfall in loop handling.","expected_answer_outline":"Difference between var (function-scoped, fully hoisted) and let/const (block-scoped, hoisted but in Temporal Dead Zone). Pitfall example: using `var` inside a `for` loop closure causes all iterations to reference the final value of the loop index; `let` solves this by creating a new binding per iteration."},{"id":2,"topic":"JavaScript: Closures","difficulty":"Hard","question":"What is a JavaScript closure? Describe a common design pattern (like the Module Pattern or function factory) where closures are essential for achieving data privacy and state encapsulation. Provide a brief code snippet demonstrating this.","expected_answer_outline":"Definition: A function bundled with its lexical environment. Essential for maintaining access to the outer function's scope even after the outer function has executed. Module Pattern: returning an object with public methods that access private variables defined within the factory function scope."},{"id":3,"topic":"JavaScript: Async/Await","difficulty":"Medium","question":"Compare the error handling mechanisms in traditional Promise chaining (`.catch()`) versus using `async/await`. When might you choose to use `Promise.all()` over sequentially awaiting multiple asynchronous calls, and what are the performance implications?","expected_answer_outline":"Promises use `.catch()` at the end of the chain; Async/Await uses standard synchronous `try...catch` blocks. `Promise.all()` is chosen when independent async operations need to run concurrently (in parallel), significantly reducing total execution time compared to sequential `await` statements."},{"id":4,"topic":"JavaScript: Advanced Features","difficulty":"Medium","question":"Explain the concept of JavaScript 'This' binding in Arrow Functions compared to regular functions. How does an Arrow Function behave when used as a method within an object literal?","expected_answer_outline":"Regular functions determine `this` based on how they are called (context/invocation site). Arrow functions lexically bind `this` (they inherit `this` from the surrounding scope where they are defined). Pitfall: Arrow functions used as object methods will incorrectly reference the global scope or the module scope (`window` or `undefined`) instead of the object itself."},{"id":5,"topic":"React: Hooks (useEffect)","difficulty":"Medium","question":"Describe the purpose of the dependency array in the `useEffect` hook. What is the consequence if you omit a necessary external variable (like a prop or state) from the dependency array, and how can the ESLint hook rule help mitigate this?","expected_answer_outline":"Dependency array controls when the effect reruns. Omission leads to stale closure issues (the effect captures an outdated value of the variable from the initial render). ESLint hook rules force the inclusion of all outside variables referenced within the effect, ensuring correct reactivity."},{"id":6,"topic":"React: Performance Optimization","difficulty":"Hard","question":"Explain the roles of `useMemo` and `useCallback`. Provide a clear scenario where using `useCallback` on a handler function passed to a child component (using `React.memo`) is crucial for preventing unnecessary re-renders. Why must the child component be memoized for `useCallback` to be effective?","expected_answer_outline":"`useMemo` memoizes computed values; `useCallback` memoizes function definitions. Scenario: Passing a `handleSave` function defined in a parent to a costly, memoized child component. If `handleSave` is recreated on every parent render, the child sees a new prop reference and re-renders unnecessarily. The child must use `React.memo` so it skips rendering if props (including the function reference) are shallowly equal."},{"id":7,"topic":"React: State Management (Context API)","difficulty":"Medium","question":"Explain the limitations of the React Context API concerning performance in large-scale applications. Describe a common optimization pattern (involving multiple contexts or value splitting) to mitigate excessive re-renders when only a small part of the context state changes.","expected_answer_outline":"Limitation: Context lacks built-in selector mechanisms. When the context value object changes, all consuming components re-render, even if they only used an unchanged part of the context. Optimization: Splitting context into smaller, focused contexts (e.g., `UserStateContext` and `UserDispatchContext`) or utilizing `useMemo` on the context provider value."},{"id":8,"topic":"React: Reconciliation","difficulty":"Medium","question":"What is the Virtual DOM and React Reconciliation? Why is using the `key` prop correctly when rendering lists absolutely critical for efficient reconciliation performance?","expected_answer_outline":"Virtual DOM is a lightweight JS representation of the UI. Reconciliation is the process where React diffs the new VDOM tree against the previous one to calculate minimal updates to the actual DOM. Keys provide stable identities to list items, allowing React to track elements uniquely and efficiently reuse/reorder existing DOM nodes instead of destroying and recreating them."},{"id":9,"topic":"React: Class Components/Lifecycle","difficulty":"Medium","question":"In a legacy Class Component, explain the difference between `componentDidMount` and `componentWillUnmount`. If a developer forgets to clean up a subscription (like an interval timer) in `componentWillUnmount`, what is the consequence?","expected_answer_outline":"`componentDidMount`: runs once after initial render (good for initial data fetching, setup). `componentWillUnmount`: runs before component destruction (good for cleanup). Consequence of forgetting cleanup: Memory leaks, and potential errors when callbacks try to reference state/props of an unmounted component."},{"id":10,"topic":"React: Advanced State","difficulty":"Hard","question":"When would you choose the `useReducer` hook over `useState` for state management within a single component? Demonstrate the advantages of `useReducer` when handling complex state transitions or managing related pieces of state.","expected_answer_outline":"Choose `useReducer` when state logic is complex, involves multiple related sub-values, or when the next state depends on the previous state in intricate ways. Advantage: Centralizes state transition logic outside the component (in the reducer function), making it easier to test and manage, often replacing large sets of interdependent `useState` calls."}]