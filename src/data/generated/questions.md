[{"id":1,"topic":"JavaScript Fundamentals (ES6 Scoping)","difficulty":"Medium","question":"Explain the differences between `var`, `let`, and `const` in terms of scoping (function-level vs. block-level) and hoisting behavior. Provide a practical example where the difference between `let` and `var` inside a loop leads to different closure outcomes.","expected_answer_outline":"Scope: `var` is function-scoped; `let`/`const` are block-scoped. Hoisting: `var` is hoisted and initialized to `undefined`; `let`/`const` are hoisted but remain in the Temporal Dead Zone (TDZ) until declaration. Loop example should demonstrate how `var` shares the iterator across closures, while `let` creates a new lexical environment for each iteration."},{"id":2,"topic":"Asynchronous JavaScript (Promises & Async/Await)","difficulty":"Medium","question":"Describe the core purpose of the JavaScript Event Loop in managing asynchronous operations. How do `async/await` constructs fundamentally simplify Promise chains, and why must an `await` always be used inside an `async` function?","expected_answer_outline":"Event Loop: Coordinates the Call Stack, Web APIs, and Callback Queue (Task/Microtask Queue) to manage non-blocking operations. Async/Await: Syntactic sugar that makes asynchronous code look synchronous, improving readability. An `await` pauses execution until the promise resolves/rejects; this pausing capability is only granted within an `async` function context."},{"id":3,"topic":"JavaScript Closures","difficulty":"Medium","question":"What is a closure? Write a brief function that uses a closure to implement a private counter or module pattern, and explain why the inner function maintains access to the outer function's variables.","expected_answer_outline":"Definition: A closure is the combination of a function bundled together with references to its surrounding state (the lexical environment). The inner function maintains access because it retains a link to the scope chain of the outer function, even after the outer function has finished execution (used for data privacy/memoization)."},{"id":4,"topic":"JavaScript DOM Manipulation & Performance","difficulty":"Medium","question":"If you need to programmatically add 500 elements to the DOM in quick succession, what performance optimization technique should you employ to minimize layout thrashing (repeated reflows/repaints)?","expected_answer_outline":"Use `document.createDocumentFragment()`. This allows appending all 500 elements to the Fragment (which exists only in memory) and then performing a single, efficient append of the Fragment to the live DOM tree. This minimizes the number of necessary reflows from 500 to 1."},{"id":5,"topic":"React Hooks (useState & useEffect)","difficulty":"Medium","question":"Explain the role and significance of the dependency array (the second argument) in the `useEffect` hook. Detail the three main behaviors based on whether the array is omitted, empty (`[]`), or contains specific variables.","expected_answer_outline":"Dependency array controls when the effect runs. 1. Omitted: Runs after every render (ComponentDidMount + ComponentDidUpdate). 2. Empty Array (`[]`): Runs only once after the initial render (ComponentDidMount). 3. Array with variables: Runs after the initial render and whenever any variable in the array changes. Crucial for avoiding infinite loops or stale closures."},{"id":6,"topic":"React Performance Optimization (Memoization)","difficulty":"Hard","question":"You have a large, complex child component receiving a callback function as a prop from its parent. If the parent frequently re-renders due to unrelated state changes, how can you ensure the child only re-renders when its props actually change? Name the specific React hooks required for both the component and the callback prop.","expected_answer_outline":"1. Component optimization: Wrap the child component using `React.memo` (performs a shallow comparison of props). 2. Callback optimization: Use the `useCallback` hook in the parent component to memoize the callback function, ensuring its reference identity remains stable unless its dependencies change. This prevents `React.memo` from failing due to reference instability."},{"id":7,"topic":"React State Management (Functional Updates)","difficulty":"Easy","question":"When updating state using the setter function from `useState`, why is it often necessary to pass a functional update (e.g., `setCount(prev => prev + 1)`) instead of directly passing the new value (e.g., `setCount(count + 1)`)?","expected_answer_outline":"Functional updates are necessary because state updates are batched and asynchronous. Using the functional form guarantees that you receive the correct, latest value of the previous state (`prev`) at the time the update is processed, avoiding concurrency issues or using stale state values."},{"id":8,"topic":"React Context API","difficulty":"Medium","question":"Compare the use cases for the Context API versus a dedicated state management library (like Redux or Zustand). What is the major performance drawback of using a single large Context Provider for highly frequently updated data?","expected_answer_outline":"Context is suitable for simple, application-wide data (themes, user info, language) that updates infrequently. Dedicated libraries are better for complex, normalized state with high update frequency or large size. Drawback: A Context Provider updates *all* consumer components whenever *any* part of the context value changes, potentially causing unnecessary re-renders throughout the application tree."},{"id":9,"topic":"React Lifecycle Mapping (Class vs Hooks)","difficulty":"Medium","question":"Map the functionalities of the three core Class Component lifecycle methods—`componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`—to their equivalents when using the single `useEffect` Hook in functional components.","expected_answer_outline":"1. `componentDidMount`: `useEffect` with an empty dependency array (`[]`). 2. `componentDidUpdate`: `useEffect` with a dependencies array containing state/props. 3. `componentWillUnmount`: The cleanup function returned from the `useEffect` callback."},{"id":10,"topic":"React Custom Hooks","difficulty":"Hard","question":"Define what a Custom Hook is and explain the fundamental principle that allows two different components using the same Custom Hook (e.g., `useToggle`) to manage state completely independently without sharing state between them.","expected_answer_outline":"Definition: A Custom Hook is a JavaScript function whose name starts with 'use' and calls other Hooks. Principle: Every time a component calls a Custom Hook, React executes that hook's code within the context of that specific component instance. Therefore, the `useState` or `useEffect` calls inside the hook create unique, isolated state and effects specifically tied to the calling component, preventing state sharing."}]